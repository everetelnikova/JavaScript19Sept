export declare const belongsToType = "belongsTo";
export declare const hasManyType = "hasMany";
export declare const hasOneType = "hasOne";
export interface RelationOpts {
    type?: string;
}
export declare abstract class Relation {
    protected TYPE_NAME: string;
    protected add: any;
    protected mapper: any;
    protected relation: any;
    name: string;
    private readonly localField;
    private readonly localKey;
    protected foreignKey: any;
    protected relatedMapper: any;
    protected inverse: any;
    constructor(relatedMapper: any, options?: RelationOpts);
    get canAutoAddLinks(): boolean;
    get relatedCollection(): any;
    validateOptions(related: any, opts: any): void;
    assignTo(mapper: any): void;
    canFindLinkFor(record?: any): boolean;
    getRelation(): any;
    getForeignKey(record: any): any;
    setForeignKey(record: any, relatedRecord: any): void;
    _setForeignKey(record: any, relatedRecords: any): void;
    getLocalField(record: any): any;
    setLocalField(record: any, relatedData: any): void;
    getInverse(mapper: any): any;
    findInverseRelation(mapper: any): void;
    isInversedTo(def: any): boolean;
    addLinkedRecords(records: any): void;
    removeLinkedRecords(relatedMapper: any, records: any): void;
    linkRecord(record: any, relatedRecord: any): any;
    findExistingLinksByForeignKey(id: any): any;
    ensureLinkedDataHasProperType(props: any, opts: any): void;
    isRequiresParentId(): boolean;
    isRequiresChildId(): boolean;
    createChildRecord(props: any, relationData: any, opts: any): any;
    createLinked(props: any, opts: any): any;
    abstract findExistingLinksFor(relatedMapper: any, record: any): any;
    abstract findExistingLinksFor(...record: any[]): any;
    static belongsTo: any;
    static hasMany: any;
    static hasOne: any;
}

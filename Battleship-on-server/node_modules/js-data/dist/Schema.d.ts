import Component from './Component';
export interface PropertyDefinition {
    type: string | string[];
    track?: boolean;
    description?: string;
    indexed?: boolean;
    items?: PropertyDefinition;
    minItems?: number;
    uniqueItems?: boolean;
    extends?: Schema;
    get?: Function;
    properties?: {
        [name: string]: PropertyDefinition;
    };
    required?: string[] | boolean;
    maximum?: number;
    exclusiveMaximum?: boolean;
    minimum?: number;
    exclusiveMinimum?: boolean;
    additionalProperties?: boolean;
}
export interface SchemaDefinition {
    type?: string;
    description?: string;
    $schema?: string;
    title?: string;
    properties?: {
        [name: string]: PropertyDefinition | any;
    };
    extends?: SchemaDefinition | Schema;
    items?: SchemaDefinition | Schema;
    track?: boolean;
    additionalProperties?: any;
    required?: string[];
}
/**
 * js-data's Schema class.
 *
 * @example <caption>Schema#constructor</caption>
 * const JSData = require('js-data');
 * const { Schema } = JSData;
 * console.log('Using JSData v' + JSData.version.full);
 *
 * const PostSchema = new Schema({
 *   type: 'object',
 *   properties: {
 *     title: { type: 'string' }
 *   }
 * });
 * PostSchema.validate({ title: 1234 });
 *
 * @example
 * const JSData = require('js-data');
 * const { Schema } = JSData;
 * console.log('Using JSData v' + JSData.version.full);
 *
 * class CustomSchemaClass extends Schema {
 *   foo () { return 'bar'; }
 *   static beep () { return 'boop'; }
 * }
 * const customSchema = new CustomSchemaClass();
 * console.log(customSchema.foo());
 * console.log(CustomSchemaClass.beep());
 *
 * @class Schema
 * @extends Component
 * @param {object} definition Schema definition according to json-schema.org
 */
export default class Schema extends Component {
    type: string;
    properties: any;
    private readonly extends;
    private readonly items;
    private readonly track;
    private readonly additionalProperties;
    constructor(definition?: SchemaDefinition);
    /**
     * This adds ES5 getters/setters to the target based on the "properties" in
     * this Schema, which makes possible change tracking and validation on
     * property assignment.
     *
     * @name Schema#apply
     * @method
     * @param {object} target The prototype to which to apply this schema.
     * @param opts
     */
    apply(target: any, opts?: any): void;
    /**
     * Apply default values to the target object for missing values.
     *
     * @name Schema#applyDefaults
     * @method
     * @param {object} target The target to which to apply values for missing values.
     */
    applyDefaults(target: any): void;
    /**
     * Assemble a property descriptor for tracking and validating changes to
     * a property according to the given schema. This method is called when
     * {@link Mapper#applySchema} is set to `true`.
     *
     * @name Schema#makeDescriptor
     * @method
     * @param {string} prop The property name.
     * @param {(Schema|object)} schema The schema for the property.
     * @param {object} [opts] Optional configuration.
     * @param {function} [opts.getter] Custom getter function.
     * @param {function} [opts.setter] Custom setter function.
     * @param {function} [opts.track] Whether to track changes.
     * @returns {object} A property descriptor for the given schema.
     */
    makeDescriptor(prop: any, schema: any, opts: any): any;
    /**
     * Create a copy of the given value that contains only the properties defined
     * in this schema.
     *
     * @name Schema#pick
     * @method
     * @param {*} value The value to copy.
     * @returns {*} The copy.
     */
    pick(value: any, opts?: any): any;
    /**
     * Validate the provided value against this schema.
     *
     * @name Schema#validate
     * @method
     * @param {*} value Value to validate.
     * @param {object} [opts] Configuration options.
     * @returns {(array|undefined)} Array of errors or `undefined` if valid.
     */
    validate(value: any, opts?: any): any[];
    static ANY_OPS: string[];
    static ARRAY_OPS: string[];
    static NUMERIC_OPS: string[];
    static OBJECT_OPS: string[];
    static STRING_OPS: string[];
    static typeGroupValidators: {
        /**
         * Validates the provided value against the schema using all of the validation keywords specific to instances of an
         * array.
         * The validation keywords for the type `array` are:
         * ```
         * ['items', 'maxItems', 'minItems', 'uniqueItems']
         * ```
         * see http://json-schema.org/latest/json-schema-validation.html#anchor25
         *
         * @name Schema.typeGroupValidators.array
         * @method
         * @param {*} value Array to be validated.
         * @param {object} schema Schema containing at least one array keyword.
         * @param {object} [opts] Configuration options.
         * @returns {(array|undefined)} Array of errors or `undefined` if valid.
         */
        array: (value: any, schema: any, opts?: any) => any[];
        /**
         * Validates the provided value against the schema using all of the validation keywords specific to instances of an
         * integer.
         * The validation keywords for the type `integer` are:
         * ```
         * ['multipleOf', 'maximum', 'minimum']
         * ```
         * @name Schema.typeGroupValidators.integer
         * @method
         * @param {*} value Number to be validated.
         * @param {object} schema Schema containing at least one `integer` keyword.
         * @param {object} [opts] Configuration options.
         * @returns {(array|undefined)} Array of errors or `undefined` if valid.
         */
        integer: (value: any, schema: any, opts: any) => any[];
        /**
         * Validates the provided value against the schema using all of the validation keywords specific to instances of an
         * number.
         * The validation keywords for the type `number` are:
         * ```
         * ['multipleOf', 'maximum', 'minimum']
         * ```
         * @name Schema.typeGroupValidators.number
         * @method
         * @param {*} value Number to be validated.
         * @param {object} schema Schema containing at least one `number` keyword.
         * @param {object} [opts] Configuration options.
         * @returns {(array|undefined)} Array of errors or `undefined` if valid.
         */
        number: (value: any, schema: any, opts: any) => any[];
        /**
         * Validates the provided value against the schema using all of the validation keywords specific to instances of a
         * number or integer.
         * The validation keywords for the type `numeric` are:
         * ```
         * ['multipleOf', 'maximum', 'minimum']
         * ```
         * See http://json-schema.org/latest/json-schema-validation.html#anchor13.
         *
         * @name Schema.typeGroupValidators.numeric
         * @method
         * @param {*} value Number to be validated.
         * @param {object} schema Schema containing at least one `numeric` keyword.
         * @param {object} [opts] Configuration options.
         * @returns {(array|undefined)} Array of errors or `undefined` if valid.
         */
        numeric: (value: any, schema: any, opts: any) => any[];
        /**
         * Validates the provided value against the schema using all of the validation keywords specific to instances of an
         * object.
         * The validation keywords for the type `object` are:
         * ```
         * ['maxProperties', 'minProperties', 'required', 'properties', 'dependencies']
         * ```
         * See http://json-schema.org/latest/json-schema-validation.html#anchor53.
         *
         * @name Schema.typeGroupValidators.object
         * @method
         * @param {*} value Object to be validated.
         * @param {object} schema Schema containing at least one `object` keyword.
         * @param {object} [opts] Configuration options.
         * @returns {(array|undefined)} Array of errors or `undefined` if valid.
         */
        object: (value: any, schema: any, opts: any) => any[];
        /**
         * Validates the provided value against the schema using all of the validation keywords specific to instances of an
         * string.
         * The validation keywords for the type `string` are:
         * ```
         * ['maxLength', 'minLength', 'pattern']
         * ```
         * See http://json-schema.org/latest/json-schema-validation.html#anchor25.
         *
         * @name Schema.typeGroupValidators.string
         * @method
         * @param {*} value String to be validated.
         * @param {object} schema Schema containing at least one `string` keyword.
         * @param {object} [opts] Configuration options.
         * @returns {(array|undefined)} Array of errors or `undefined` if valid.
         */
        string: (value: any, schema: any, opts?: any) => any[];
    };
    static types: {
        array: (arg: any) => arg is any[];
        boolean: (value: any) => boolean;
        integer: (value: any) => boolean;
        null: (value: any) => boolean;
        number: (value: any) => boolean;
        object: (value: any) => boolean;
        string: (value: any) => boolean;
    };
    static validate: (value: any, schema: any, opts?: any) => any[];
    static validationKeywords: any;
}

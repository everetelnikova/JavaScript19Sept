import Component from './Component';
export interface QueryDefinition {
    [attr: string]: any;
    where?: any;
    orderBy?: any;
    sort?: any;
    skip?: number;
    limit?: number;
    offset?: number;
}
/**
 * A class used by the {@link Collection} class to build queries to be executed
 * against the collection's data. An instance of `Query` is returned by
 * {@link Collection#query}. Query instances are typically short-lived, and you
 * shouldn't have to create them yourself. Just use {@link Collection#query}.
 *
 * ```javascript
 * import { Query } from 'js-data';
 * ```
 *
 * @example <caption>Query intro</caption>
 * const JSData = require('js-data');
 * const { DataStore } = JSData;
 * console.log('Using JSData v' + JSData.version.full);
 *
 * const store = new DataStore();
 * store.defineMapper('post');
 * const posts = [
 *   { author: 'John', age: 30, status: 'published', id: 1 },
 *   { author: 'Sally', age: 31, status: 'draft', id: 2 },
 *   { author: 'Mike', age: 32, status: 'draft', id: 3 },
 *   { author: 'Adam', age: 33, status: 'deleted', id: 4 },
 *   { author: 'Adam', age: 33, status: 'draft', id: 5 }
 * ]
 * store.add('post', posts);
 * const drafts = store.query('post').filter({ status: 'draft' }).limit(2).run();
 * console.log(drafts);
 *
 * @class Query
 * @extends Component
 * @param {Collection} collection The collection on which this query operates.
 * @since 3.0.0
 */
export default class Query extends Component {
    collection?: any;
    /**
     * The current data result of this query.
     *
     * @name Query#data
     * @since 3.0.0
     * @type {Array}
     */
    private data;
    constructor(collection?: any);
    _applyWhereFromObject(where: any): {
        fields: any[];
        ops: any[];
        predicates: any[];
    };
    _applyWhereFromArray(where: any): any;
    _testObjectGroup(keep: any, first: any, group: any, item: any): {
        keep: any;
        first: any;
    };
    _testArrayGroup(keep: any, first: any, groups: any, item: any): {
        keep: any;
        first: any;
    };
    /**
     * Find all entities between two boundaries.
     *
     * @example <caption>Get the users ages 18 to 30.</caption>
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('user');
     * const users = [
     *   { name: 'Peter', age: 25, id: 1 },
     *   { name: 'Jim', age: 19, id: 2 },
     *   { name: 'Mike', age: 17, id: 3 },
     *   { name: 'Alan', age: 29, id: 4 },
     *   { name: 'Katie', age: 33, id: 5 }
     * ];
     * store.add('user', users)
     * const filteredUsers = store
     *   .query('user')
     *   .between(18, 30, { index: 'age' })
     *   .run();
     * console.log(filteredUsers);
     *
     * @example <caption>Same as above.</caption>
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('user');
     * const users = [
     *   { name: 'Peter', age: 25, id: 1 },
     *   { name: 'Jim', age: 19, id: 2 },
     *   { name: 'Mike', age: 17, id: 3 },
     *   { name: 'Alan', age: 29, id: 4 },
     *   { name: 'Katie', age: 33, id: 5 }
     * ];
     * store.add('user', users)
     * const filteredUsers = store
     *   .query('user')
     *   .between([18], [30], { index: 'age' })
     *   .run();
     * console.log(filteredUsers);
     *
     * @method Query#between
     * @param {array} leftKeys Keys defining the left boundary.
     * @param {array} rightKeys Keys defining the right boundary.
     * @param {object} [opts] Configuration options.
     * @param {string} [opts.index] Name of the secondary index to use in the
     * query. If no index is specified, the main index is used.
     * @param {boolean} [opts.leftInclusive=true] Whether to include entities
     * on the left boundary.
     * @param {boolean} [opts.rightInclusive=false] Whether to include entities
     * on the left boundary.
     * @param {boolean} [opts.limit] Limit the result to a certain number.
     * @param {boolean} [opts.offset] The number of resulting entities to skip.
     * @returns {Query} A reference to itself for chaining.
     * @since 3.0.0
     */
    between(leftKeys?: any, rightKeys?: any, opts?: any): this;
    /**
     * The comparison function used by the {@link Query} class.
     *
     * @method Query#compare
     * @param {array} orderBy An orderBy clause used for sorting and sub-sorting.
     * @param {number} index The index of the current orderBy clause being used.
     * @param {*} a The first item in the comparison.
     * @param {*} b The second item in the comparison.
     * @returns {number} -1 if `b` should preceed `a`. 0 if `a` and `b` are equal.
     * 1 if `a` should preceed `b`.
     * @since 3.0.0
     */
    compare(orderBy: any, index: any, a: any, b: any, compare: any): any;
    /**
     * Predicate evaluation function used by the {@link Query} class.
     *
     * @method Query#evaluate
     * @param {*} value The value to evaluate.
     * @param {string} op The operator to use in this evaluation.
     * @param {*} predicate The predicate to use in this evaluation.
     * @returns {boolean} Whether the value passed the evaluation or not.
     * @since 3.0.0
     */
    evaluate(value: any, op: any, predicate: any): any;
    /**
     * Find the record or records that match the provided query or are accepted by
     * the provided filter function.
     *
     * @example <caption>Get the draft posts by authors younger than 30</caption>
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('post')
     * const posts = [
     *   { author: 'John', age: 30, status: 'published', id: 1 },
     *   { author: 'Sally', age: 31, status: 'published', id: 2 },
     *   { author: 'Mike', age: 32, status: 'draft', id: 3 },
     *   { author: 'Adam', age: 33, status: 'deleted', id: 4 },
     *   { author: 'Adam', age: 33, status: 'published', id: 5 }
     *   { author: 'Peter', age: 25, status: 'deleted', id: 6 },
     *   { author: 'Sally', age: 21, status: 'draft', id: 7 },
     *   { author: 'Jim', age: 27, status: 'draft', id: 8 },
     *   { author: 'Jim', age: 27, status: 'published', id: 9 },
     *   { author: 'Jason', age: 55, status: 'published', id: 10 }
     * ];
     * store.add('post', posts);
     * const results = store
     *   .query('post')
     *   .filter({
     *     where: {
     *       status: {
     *         '==': 'draft'
     *       },
     *       age: {
     *         '<': 30
     *       }
     *     }
     *   })
     *   .run();
     * console.log(results);
     *
     * @example <caption>Use a custom filter function</caption>
     * const posts = query
     *   .filter(function (post) {
     *     return post.isReady();
     *   })
     *   .run();
     *
     * @method Query#filter
     * @param {(Object|Function)} [query={}] Selection query or filter
     * function.
     * @param {Function} [thisArg] Context to which to bind `queryOrFn` if
     * `queryOrFn` is a function.
     * @returns {Query} A reference to itself for chaining.
     * @since 3.0.0
     */
    filter(query?: QueryDefinition, thisArg?: Function): Query;
    /**
     * Iterate over all entities.
     *
     * @method Query#forEach
     * @param {Function} forEachFn Iteration function.
     * @param {*} [thisArg] Context to which to bind `forEachFn`.
     * @returns {Query} A reference to itself for chaining.
     * @since 3.0.0
     */
    forEach(forEachFn: Function, thisArg?: any): this;
    /**
     * Find the entity or entities that match the provided key.
     *
     * @example <caption>Get the entity whose primary key is 25.</caption>
     * const entities = query.get(25).run();
     *
     * @example <caption>Same as above.</caption>
     * const entities = query.get([25]).run();
     *
     * @example <caption>Get all users who are active and have the "admin" role.</caption>
     * const activeAdmins = query.get(['active', 'admin'], {
     *   index: 'activityAndRoles'
     * }).run();
     *
     * @example <caption>Get all entities that match a certain weather condition.</caption>
     * const niceDays = query.get(['sunny', 'humid', 'calm'], {
     *   index: 'weatherConditions'
     * }).run();
     *
     * @method Query#get
     * @param {array} keyList Key(s) defining the entity to retrieve. If
     * `keyList` is not an array (i.e. for a single-value key), it will be
     * wrapped in an array.
     * @param {object} [opts] Configuration options.
     * @param {string} [opts.string] Name of the secondary index to use in the
     * query. If no index is specified, the main index is used.
     * @returns {Query} A reference to itself for chaining.
     * @since 3.0.0
     */
    get(keyList?: any[], opts?: any): this;
    /**
     * Find the entity or entities that match the provided keyLists.
     *
     * @example <caption>Get the posts where "status" is "draft" or "inReview".</caption>
     * const posts = query.getAll('draft', 'inReview', { index: 'status' }).run();
     *
     * @example <caption>Same as above.</caption>
     * const posts = query.getAll(['draft'], ['inReview'], { index: 'status' }).run();
     *
     * @method Query#getAll
     * @param {...Array} [keyList] Provide one or more keyLists, and all
     * entities matching each keyList will be retrieved. If no keyLists are
     * provided, all entities will be returned.
     * @param {object} [opts] Configuration options.
     * @param {string} [opts.index] Name of the secondary index to use in the
     * query. If no index is specified, the main index is used.
     * @returns {Query} A reference to itself for chaining.
     * @since 3.0.0
     */
    getAll(keyList?: [], opts?: any): any;
    /**
     * Return the current data result of this query.
     *
     * @method Query#getData
     * @returns {Array} The data in this query.
     * @since 3.0.0
     */
    getData(): any;
    /**
     * Implementation used by the `like` operator. Takes a pattern and flags and
     * returns a `RegExp` instance that can test strings.
     *
     * @method Query#like
     * @param {string} pattern Testing pattern.
     * @param {string} flags Flags for the regular expression.
     * @returns {RegExp} Regular expression for testing strings.
     * @since 3.0.0
     */
    like(pattern: any, flags: any): RegExp;
    /**
     * Limit the result.
     *
     * @example <caption>Get only the first 2 posts.</caption>
     * const store = new JSData.DataStore();
     * store.defineMapper('post');
     * const posts = [
     *   { author: 'John', age: 30, status: 'published', id: 1 },
     *   { author: 'Sally', age: 31, status: 'draft', id: 2 },
     *   { author: 'Mike', age: 32, status: 'draft', id: 3 },
     *   { author: 'Adam', age: 33, status: 'deleted', id: 4 },
     *   { author: 'Adam', age: 33, status: 'draft', id: 5 }
     * ];
     * store.add('post', posts);
     * const results = store.query('post').limit(2).run();
     * console.log(results);
     *
     * @method Query#limit
     * @param {number} num The maximum number of entities to keep in the result.
     * @returns {Query} A reference to itself for chaining.
     * @since 3.0.0
     */
    limit(num: any): this;
    /**
     * Apply a mapping function to the result data.
     *
     * @example
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('user');
     * const users = [
     *   { name: 'Peter', age: 25, id: 1 },
     *   { name: 'Jim', age: 19, id: 2 },
     *   { name: 'Mike', age: 17, id: 3 },
     *   { name: 'Alan', age: 29, id: 4 },
     *   { name: 'Katie', age: 33, id: 5 }
     * ];
     * store.add('user', users);
     * const ages = store
     *   .query('user')
     *   .map(function (user) {
     *     return user.age;
     *   })
     *   .run();
     * console.log(ages);
     *
     * @method Query#map
     * @param {Function} mapFn Mapping function.
     * @param {*} [thisArg] Context to which to bind `mapFn`.
     * @returns {Query} A reference to itself for chaining.
     * @since 3.0.0
     */
    map(mapFn: any, thisArg?: any): this;
    /**
     * Return the result of calling the specified function on each item in this
     * collection's main index.
     *
     * @example
     * const stringAges = UserCollection.query().mapCall('toString').run();
     *
     * @method Query#mapCall
     * @param {string} funcName Name of function to call
     * @param args Remaining arguments to be passed to the function.
     * @returns {Query} A reference to itself for chaining.
     * @since 3.0.0
     */
    mapCall(funcName: any, ...args: any[]): this;
    /**
     * Complete the execution of the query and return the resulting data.
     *
     * @method Query#run
     * @returns {Array} The result of executing this query.
     * @since 3.0.0
     */
    run(): any;
    /**
     * Skip a number of results.
     *
     * @example <caption>Get all but the first 2 posts.</caption>
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('post');
     * const posts = [
     *   { author: 'John', age: 30, status: 'published', id: 1 },
     *   { author: 'Sally', age: 31, status: 'draft', id: 2 },
     *   { author: 'Mike', age: 32, status: 'draft', id: 3 },
     *   { author: 'Adam', age: 33, status: 'deleted', id: 4 },
     *   { author: 'Adam', age: 33, status: 'draft', id: 5 }
     * ];
     * store.add('post', posts);
     * const results = store.query('post').skip(2).run();
     * console.log(results);
     *
     * @method Query#skip
     * @param {number} num The number of entities to skip.
     * @returns {Query} A reference to itself for chaining.
     * @since 3.0.0
     */
    skip(num: any): this;
    /**
     * The filtering operators supported by {@link Query#filter}, and which are
     * implemented by adapters (for the most part).
     *
     * @example <caption>Variant 1</caption>
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('post');
     * const posts = [
     *   { author: 'John', age: 30, status: 'published', id: 1 },
     *   { author: 'Sally', age: 31, status: 'published', id: 2 },
     *   { author: 'Mike', age: 32, status: 'published', id: 3 },
     *   { author: 'Adam', age: 33, status: 'deleted', id: 4 },
     *   { author: 'Adam', age: 33, status: 'published', id: 5 }
     * ];
     * store.add('post', posts);
     * const publishedPosts = store.filter('post', {
     *   status: 'published',
     *   limit: 2
     * });
     * console.log(publishedPosts);
     *
     *
     * @example <caption>Variant 2</caption>
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('post')
     * const posts = [
     *   { author: 'John', age: 30, status: 'published', id: 1 },
     *   { author: 'Sally', age: 31, status: 'published', id: 2 },
     *   { author: 'Mike', age: 32, status: 'published', id: 3 },
     *   { author: 'Adam', age: 33, status: 'deleted', id: 4 },
     *   { author: 'Adam', age: 33, status: 'published', id: 5 }
     * ];
     * store.add('post', posts);
     * const publishedPosts = store.filter('post', {
     *   where: {
     *     status: {
     *       '==': 'published'
     *     }
     *   },
     *   limit: 2
     * });
     * console.log(publishedPosts);
     *
     * @example <caption>Variant 3</caption>
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('post');
     * const posts = [
     *   { author: 'John', age: 30, status: 'published', id: 1 },
     *   { author: 'Sally', age: 31, status: 'published', id: 2 },
     *   { author: 'Mike', age: 32, status: 'published', id: 3 },
     *   { author: 'Adam', age: 33, status: 'deleted', id: 4 },
     *   { author: 'Adam', age: 33, status: 'published', id: 5 }
     * ];
     * store.add('post', posts);
     * const publishedPosts = store
     *   .query('post')
     *   .filter({ status: 'published' })
     *   .limit(2)
     *   .run();
     * console.log(publishedPosts);
     *
     * @example <caption>Variant 4</caption>
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('post');
     * const posts = [
     *   { author: 'John', age: 30, status: 'published', id: 1 },
     *   { author: 'Sally', age: 31, status: 'published', id: 2 },
     *   { author: 'Mike', age: 32, status: 'published', id: 3 },
     *   { author: 'Adam', age: 33, status: 'deleted', id: 4 },
     *   { author: 'Adam', age: 33, status: 'published', id: 5 }
     * ];
     * store.add('post', posts);
     * const publishedPosts = store
     *   .query('post')
     *   .filter({
     *     where: {
     *       status: {
     *         '==': 'published'
     *       }
     *     }
     *   })
     *   .limit(2)
     *   .run();
     * console.log(publishedPosts);
     *
     * @example <caption>Multiple operators</caption>
     * const JSData = require('js-data');
     * const { DataStore } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const store = new DataStore();
     * store.defineMapper('post');
     * const posts = [
     *   { author: 'John', age: 30, status: 'published', id: 1 },
     *   { author: 'Sally', age: 31, status: 'published', id: 2 },
     *   { author: 'Mike', age: 32, status: 'published', id: 3 },
     *   { author: 'Adam', age: 33, status: 'deleted', id: 4 },
     *   { author: 'Adam', age: 33, status: 'published', id: 5 }
     * ];
     * store.add('post', posts);
     *
     * const myPublishedPosts = store.filter('post', {
     *   where: {
     *     status: {
     *       '==': 'published'
     *     },
     *     user_id: {
     *       '==': currentUser.id
     *     }
     *   }
     * });
     *
     * console.log(myPublishedPosts);
     *
     * @name Query.ops
     * @property {Function} == Equality operator.
     * @property {Function} != Inequality operator.
     * @property {Function} > Greater than operator.
     * @property {Function} >= Greater than (inclusive) operator.
     * @property {Function} < Less than operator.
     * @property {Function} <= Less than (inclusive) operator.
     * @property {Function} isectEmpty Operator that asserts that the intersection
     * between two arrays is empty.
     * @property {Function} isectNotEmpty Operator that asserts that the
     * intersection between two arrays is __not__ empty.
     * @property {Function} in Operator that asserts whether a value is in an
     * array.
     * @property {Function} notIn Operator that asserts whether a value is __not__
     * in an array.
     * @property {Function} contains Operator that asserts whether an array
     * contains a value.
     * @property {Function} notContains Operator that asserts whether an array
     * does __not__ contain a value.
     * @since 3.0.0
     * @type {Object}
     */
    static ops: {
        '='(value: any, predicate: any): boolean;
        '=='(value: any, predicate: any): boolean;
        '==='(value: any, predicate: any): boolean;
        '!='(value: any, predicate: any): boolean;
        '!=='(value: any, predicate: any): boolean;
        '>'(value: any, predicate: any): boolean;
        '>='(value: any, predicate: any): boolean;
        '<'(value: any, predicate: any): boolean;
        '<='(value: any, predicate: any): boolean;
        isectEmpty(value: any, predicate: any): boolean;
        isectNotEmpty(value: any, predicate: any): number;
        in(value: any, predicate: any): boolean;
        notIn(value: any, predicate: any): boolean;
        contains(value: any, predicate: any): boolean;
        notContains(value: any, predicate: any): boolean;
    };
}

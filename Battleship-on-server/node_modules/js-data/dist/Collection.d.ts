import Component, { ComponentOpts } from './Component';
import Query from './Query';
import Index from './mindex';
export interface CollectionOpts extends ComponentOpts {
    /**
     * Whether to call {@link Record#commit} on records that are added to the
     * collection and already exist in the collection.
     *
     * @name Collection#commitOnMerge
     * @type {boolean}
     * @default true
     */
    commitOnMerge?: boolean;
    /**
     * Whether record events should bubble up and be emitted by the collection.
     *
     * @name Collection#emitRecordEvents
     * @type {boolean}
     * @default true
     */
    emitRecordEvents?: boolean;
    /**
     * Field to be used as the unique identifier for records in this collection.
     * Defaults to `"id"` unless {@link Collection#mapper} is set, in which case
     * this will default to {@link Mapper#idAttribute}.
     *
     * @name Collection#idAttribute
     * @type {string}
     * @default "id"
     */
    idAttribute?: string;
    /**
     * What to do when inserting a record into this Collection that shares a
     * primary key with a record already in this Collection.
     *
     * Possible values:
     * merge
     * replace
     * skip
     *
     * Merge:
     *
     * Recursively shallow copy properties from the new record onto the existing
     * record.
     *
     * Replace:
     *
     * Shallow copy top-level properties from the new record onto the existing
     * record. Any top-level own properties of the existing record that are _not_
     * on the new record will be removed.
     *
     * Skip:
     *
     * Ignore new record, keep existing record.
     *
     * @default "merge"
     */
    onConflict?: 'merge' | 'replace' | 'skip';
}
/**
 * An ordered set of {@link Record} instances.
 *
 * @example <caption>Collection#constructor</caption>
 * // import { Collection, Record } from 'js-data';
 * const JSData = require('js-data');
 * const {Collection, Record} = JSData;
 * console.log('Using JSData v' + JSData.version.full);
 *
 * const user1 = new Record({ id: 1 });
 * const user2 = new Record({ id: 2 });
 * const UserCollection = new Collection([user1, user2]);
 * console.log(UserCollection.get(1) === user1);
 *
 * @class Collection
 * @extends Component
 * @param {array} [records] Initial set of records to insert into the
 * collection.
 * @param {object} [opts] Configuration options.
 * @param {string} [opts.commitOnMerge] See {@link Collection#commitOnMerge}.
 * @param {string} [opts.idAttribute] See {@link Collection#idAttribute}.
 * @param {string} [opts.onConflict="merge"] See {@link Collection#onConflict}.
 * @param {string} [opts.mapper] See {@link Collection#mapper}.
 * @since 3.0.0
 */
export default class Collection extends Component {
    queryClass: any;
    emitRecordEvents: any;
    onConflict: string;
    /**
     * Default Mapper for this collection. Optional. If a Mapper is provided, then
     * the collection will use the {@link Mapper#idAttribute} setting, and will
     * wrap records in {@link Mapper#recordClass}.
     *
     * @example <caption>Collection#mapper</caption>
     * const JSData = require('js-data');
     * const {Collection, Mapper} = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * class MyMapperClass extends Mapper {
     *   foo () { return 'bar'; }
     * }
     * const myMapper = new MyMapperClass({ name: 'myMapper' });
     * const collection = new Collection(null, { mapper: myMapper });
     *
     * @name Collection#mapper
     * @type {Mapper}
     * @default null
     * @since 3.0.0
     */
    mapper: any;
    /**
     * The main index, which uses @{link Collection#recordId} as the key.
     *
     * @name Collection#index
     * @type {Index}
     */
    index: Index;
    /**
     * Object that holds the secondary indexes of this collection.
     *
     * @name Collection#indexes
     * @type {Object.<string, Index>}
     */
    indexes: {
        [key: string]: Index;
    };
    idAttribute: any;
    _added: {};
    emit: any;
    constructor(records?: any, opts?: CollectionOpts | string | any);
    /**
     * Used to bind to events emitted by records in this Collection.
     *
     * @method Collection#_onRecordEvent
     * @since 3.0.0
     * @private
     * @param {...*} [args] Args passed to {@link Collection#emit}.
     */
    _onRecordEvent(...args: any[]): void;
    /**
     * Insert the provided record or records.
     *
     * If a record is already in the collection then the provided record will
     * either merge with or replace the existing record based on the value of the
     * `onConflict` option.
     *
     * The collection's secondary indexes will be updated as each record is
     * visited.
     *
     * @method Collection#add
     * @since 3.0.0
     * @param {(Object|Object[]|Record|Record[])} records The record or records to insert.
     * @param {object} [opts] Configuration options.
     * @param {boolean} [opts.commitOnMerge=true] See {@link Collection#commitOnMerge}.
     * @param {boolean} [opts.noValidate] See {@link Record#noValidate}.
     * @param {string} [opts.onConflict] See {@link Collection#onConflict}.
     * @returns {(Object|Object[]|Record|Record[])} The added record or records.
     */
    add(records: any, opts?: any): any;
    /**
     * Lifecycle hook called by {@link Collection#add}. If this method returns a
     * value then {@link Collection#add} will return that same value.
     *
     * @method Collection#method
     * @since 3.0.0
     * @param {(Object|Object[]|Record|Record[])} record The record or records
     * that were added to this Collection by {@link Collection#add}.
     * @param {object} opts The `opts` argument passed to {@link Collection#add}.
     * @param result
     */
    afterAdd(record: any, opts: any, result: any): any;
    /**
     * Lifecycle hook called by {@link Collection#remove}. If this method returns
     * a value then {@link Collection#remove} will return that same value.
     *
     * @method Collection#afterRemove
     * @since 3.0.0
     * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}.
     * @param {object} opts The `opts` argument passed to {@link Collection#remove}.
     * @param {object} record The result that will be returned by {@link Collection#remove}.
     */
    afterRemove(id: any, opts: any, record: any): any;
    /**
     * Lifecycle hook called by {@link Collection#removeAll}. If this method
     * returns a value then {@link Collection#removeAll} will return that same
     * value.
     *
     * @method Collection#afterRemoveAll
     * @since 3.0.0
     * @param {object} query The `query` argument passed to {@link Collection#removeAll}.
     * @param {object} opts The `opts` argument passed to {@link Collection#removeAll}.
     * @param {object} records The result that will be returned by {@link Collection#removeAll}.
     */
    afterRemoveAll(query: any, opts: any, records: any): any;
    /**
     * Lifecycle hook called by {@link Collection#add}. If this method returns a
     * value then the `records` argument in {@link Collection#add} will be
     * re-assigned to the returned value.
     *
     * @method Collection#beforeAdd
     * @since 3.0.0
     * @param {(Object|Object[]|Record|Record[])} records The `records` argument passed to {@link Collection#add}.
     * @param {object} opts The `opts` argument passed to {@link Collection#add}.
     */
    beforeAdd(records: any, opts: any): any;
    /**
     * Lifecycle hook called by {@link Collection#remove}.
     *
     * @method Collection#beforeRemove
     * @since 3.0.0
     * @param {(string|number)} id The `id` argument passed to {@link Collection#remove}.
     * @param {object} opts The `opts` argument passed to {@link Collection#remove}.
     */
    beforeRemove(id: any, opts: any): any;
    /**
     * Lifecycle hook called by {@link Collection#removeAll}.
     *
     * @method Collection#beforeRemoveAll
     * @since 3.0.0
     * @param {object} query The `query` argument passed to {@link Collection#removeAll}.
     * @param {object} opts The `opts` argument passed to {@link Collection#removeAll}.
     */
    beforeRemoveAll(query: any, opts: any): any;
    /**
     * Find all records between two boundaries.
     *
     * Shortcut for `collection.query().between(18, 30, { index: 'age' }).run()`
     *
     * @example
     * // Get all users ages 18 to 30
     * const users = collection.between(18, 30, { index: 'age' });
     *
     * @example
     * // Same as above
     * const users = collection.between([18], [30], { index: 'age' });
     *
     * @method Collection#between
     * @since 3.0.0
     * @param {array} leftKeys Keys defining the left boundary.
     * @param {array} rightKeys Keys defining the right boundary.
     * @param {object} [opts] Configuration options.
     * @param {string} [opts.index] Name of the secondary index to use in the
     * query. If no index is specified, the main index is used.
     * @param {boolean} [opts.leftInclusive=true] Whether to include records
     * on the left boundary.
     * @param {boolean} [opts.rightInclusive=false] Whether to include records
     * on the left boundary.
     * @param {boolean} [opts.limit] Limit the result to a certain number.
     * @param {boolean} [opts.offset] The number of resulting records to skip.
     * @returns {Object[]|Record[]} The result.
     */
    between(leftKeys: any, rightKeys: any, opts: any): any;
    /**
     * Create a new secondary index on the contents of the collection.
     *
     * @example
     * // Index users by age
     * collection.createIndex('age');
     *
     * @example
     * // Index users by status and role
     * collection.createIndex('statusAndRole', ['status', 'role']);
     *
     * @method Collection#createIndex
     * @since 3.0.0
     * @param {string} name The name of the new secondary index.
     * @param {string[]} [fieldList] Array of field names to use as the key or
     * compound key of the new secondary index. If no fieldList is provided, then
     * the name will also be the field that is used to index the collection.
     * @param opts
     */
    createIndex(name: any, fieldList?: any, opts?: any): void;
    /**
     * Find the record or records that match the provided query or pass the
     * provided filter function.
     *
     * Shortcut for `collection.query().filter(queryOrFn[, thisArg]).run()`
     *
     * @example <caption>Collection#filter</caption>
     * const JSData = require('js-data');
     * const { Collection } = JSData;
     * console.log('Using JSData v' + JSData.version.full);
     *
     * const collection = new Collection([
     *   { id: 1, status: 'draft', created_at_timestamp: new Date().getTime() }
     * ]);
     *
     * // Get the draft posts created less than three months ago
     * let posts = collection.filter({
     *   where: {
     *     status: {
     *       '==': 'draft'
     *     },
     *     created_at_timestamp: {
     *       '>=': (new Date().getTime() - (1000 \* 60 \* 60 \* 24 \* 30 \* 3)) // 3 months ago
     *     }
     *   }
     * });
     * console.log(posts);
     *
     * // Use a custom filter function
     * posts = collection.filter((post) => post.id % 2 === 0);
     *
     * @method Collection#filter
     * @param {(Object|Function)} [queryOrFn={}] Selection query or filter
     * function.
     * @param {object} [thisArg] Context to which to bind `queryOrFn` if
     * `queryOrFn` is a function.
     * @returns {Array} The result.
     * @see query
     * @since 3.0.0
     */
    filter(queryOrFn: any, thisArg?: any): any;
    /**
     * Iterate over all records.
     *
     * @example
     * collection.forEach(function (record) {
     *   // do something
     * });
     *
     * @method Collection#forEach
     * @since 3.0.0
     * @param {Function} forEachFn Iteration function.
     * @param {*} [thisArg] Context to which to bind `forEachFn`.
     * @returns {Array} The result.
     */
    forEach(forEachFn: any, thisArg?: any): void;
    /**
     * Get the record with the given id.
     *
     * @method Collection#get
     * @since 3.0.0
     * @param {(string|number)} id The primary key of the record to get.
     * @returns {(Object|Record)} The record with the given id.
     */
    get(id: any): any;
    /**
     * Find the record or records that match the provided keyLists.
     *
     * Shortcut for `collection.query().getAll(keyList1, keyList2, ...).run()`
     *
     * @example
     * // Get the posts where "status" is "draft" or "inReview"
     * const posts = collection.getAll('draft', 'inReview', { index: 'status' });
     *
     * @example
     * // Same as above
     * const posts = collection.getAll(['draft'], ['inReview'], { index: 'status' });
     *
     * @method Collection#getAll
     * @since 3.0.0
     * @param {...Array} [keyList] Provide one or more keyLists, and all
     * records matching each keyList will be retrieved. If no keyLists are
     * provided, all records will be returned.
     * @param {object} [opts] Configuration options.
     * @param {string} [opts.index] Name of the secondary index to use in the
     * query. If no index is specified, the main index is used.
     * @returns {Array} The result.
     */
    getAll(keyList?: Array<string | number> | string | number, opts?: any): any;
    getAll(keyList?: Array<string | number> | string | number, ...args: any[]): any;
    /**
     * Return the index with the given name. If no name is provided, return the
     * main index. Throws an error if the specified index does not exist.
     *
     * @method Collection#getIndex
     * @since 3.0.0
     * @param {string} [name] The name of the index to retrieve.
     */
    getIndex(name: any): Index;
    /**
     * Limit the result.
     *
     * Shortcut for `collection.query().limit(maximumNumber).run()`
     *
     * @example
     * const posts = collection.limit(10);
     *
     * @method Collection#limit
     * @since 3.0.0
     * @param {number} num The maximum number of records to keep in the result.
     * @returns {Array} The result.
     */
    limit(num: any): any;
    /**
     * Apply a mapping function to all records.
     *
     * @example
     * const names = collection.map((user) => user.name);
     *
     * @method Collection#map
     * @since 3.0.0
     * @param {Function} mapFn Mapping function.
     * @param {*} [thisArg] Context to which to bind `mapFn`.
     * @returns {Array} The result of the mapping.
     */
    map(cb: any, thisArg: any): any[];
    /**
     * Return the result of calling the specified function on each record in this
     * collection's main index.
     *
     * @method Collection#mapCall
     * @since 3.0.0
     * @param {string} funcName Name of function to call
     * @param {...*} [args] Remaining arguments to be passed to the function.
     * @returns {Array} The result.
     */
    mapCall(funcName: any, ...args: any[]): any[];
    /**
     * Return all "unsaved" (not uniquely identifiable) records in this colleciton.
     *
     * @method Collection#prune
     * @param {object} [opts] Configuration options, passed to {@link Collection#removeAll}.
     * @since 3.0.0
     * @returns {Array} The removed records, if any.
     */
    prune(opts: any): any;
    /**
     * Create a new query to be executed against the contents of the collection.
     * The result will be all or a subset of the contents of the collection.
     *
     * @example
     * // Grab page 2 of users between ages 18 and 30
     * collection.query()
     *   .between(18, 30, { index: 'age' }) // between ages 18 and 30
     *   .skip(10) // second page
     *   .limit(10) // page size
     *   .run();
     *
     * @method Collection#query
     * @since 3.0.0
     * @returns {Query} New query object.
     */
    query(): Query;
    /**
     * Return the primary key of the given, or if no record is provided, return the
     * name of the field that holds the primary key of records in this Collection.
     *
     * @method Collection#recordId
     * @since 3.0.0
     * @param {(Object|Record)} [record] The record whose primary key is to be
     * returned.
     * @returns {(string|number)} Primary key or name of field that holds primary
     * key.
     */
    recordId(record?: any): any;
    /**
     * Reduce the data in the collection to a single value and return the result.
     *
     * @example
     * const totalVotes = collection.reduce((prev, record) => {
     *   return prev + record.upVotes + record.downVotes;
     * }, 0);
     *
     * @method Collection#reduce
     * @since 3.0.0
     * @param {Function} cb Reduction callback.
     * @param {*} initialValue Initial value of the reduction.
     * @returns {*} The result.
     */
    reduce(cb: any, initialValue: any): any;
    /**
     * Remove the record with the given id from this Collection.
     *
     * @method Collection#remove
     * @since 3.0.0
     * @param {(string|number|object|Record)} idOrRecord The primary key of the
     * record to be removed, or a reference to the record that is to be removed.
     * @param {object} [opts] Configuration options.
     * @returns {Object|Record} The removed record, if any.
     */
    remove(idOrRecord: any, opts?: any): any;
    /**
     * Remove from this collection the given records or the records selected by
     * the given "query".
     *
     * @method Collection#removeAll
     * @since 3.0.0
     * @param {Object|Object[]|Record[]} [queryOrRecords={}] Records to be removed or selection query. See {@link query}.
     * @param {object} [queryOrRecords.where] See {@link query.where}.
     * @param {number} [queryOrRecords.offset] See {@link query.offset}.
     * @param {number} [queryOrRecords.limit] See {@link query.limit}.
     * @param {string|Array[]} [queryOrRecords.orderBy] See {@link query.orderBy}.
     * @param {object} [opts] Configuration options.
     * @returns {(Object[]|Record[])} The removed records, if any.
     */
    removeAll(queryOrRecords: any, opts?: any): any;
    /**
     * Skip a number of results.
     *
     * Shortcut for `collection.query().skip(numberToSkip).run()`
     *
     * @example
     * const posts = collection.skip(10);
     *
     * @method Collection#skip
     * @since 3.0.0
     * @param {number} num The number of records to skip.
     * @returns {Array} The result.
     */
    skip(num: any): any;
    /**
     * Return the plain JSON representation of all items in this collection.
     * Assumes records in this collection have a toJSON method.
     *
     * @method Collection#toJSON
     * @since 3.0.0
     * @param {object} [opts] Configuration options.
     * @param {string[]} [opts.with] Array of relation names or relation fields
     * to include in the representation.
     * @returns {Array} The records.
     */
    toJSON(opts?: any): any[];
    /**
     * Return all "unsaved" (not uniquely identifiable) records in this colleciton.
     *
     * @method Collection#unsaved
     * @since 3.0.0
     * @returns {Array} The unsaved records, if any.
     */
    unsaved(opts?: any): any;
    /**
     * Update a record's position in a single index of this collection. See
     * {@link Collection#updateIndexes} to update a record's position in all
     * indexes at once.
     *
     * @method Collection#updateIndex
     * @since 3.0.0
     * @param {object} record The record to update.
     * @param {object} [opts] Configuration options.
     * @param {string} [opts.index] The index in which to update the record's
     * position. If you don't specify an index then the record will be updated
     * in the main index.
     */
    updateIndex(record: any, opts?: {
        index?: string;
    }): void;
    /**
     * Updates all indexes in this collection for the provided record. Has no
     * effect if the record is not in the collection.
     *
     * @method Collection#updateIndexes
     * @since 3.0.0
     * @param {object} record TODO
     */
    updateIndexes(record: any): void;
}
/**
 * Fired when a record changes. Only works for records that have tracked changes.
 * See {@link Collection~changeListener} on how to listen for this event.
 *
 * @event Collection#change
 * @see Collection~changeListener
 */
/**
 * Callback signature for the {@link Collection#event:change} event.
 *
 * @example
 * function onChange (record, changes) {
 *   // do something
 * }
 * collection.on('change', onChange);
 *
 * @callback Collection~changeListener
 * @param {Record} The Record that changed.
 * @param {object} The changes.
 * @see Collection#event:change
 * @since 3.0.0
 */
/**
 * Fired when one or more records are added to the Collection. See
 * {@link Collection~addListener} on how to listen for this event.
 *
 * @event Collection#add
 * @see Collection~addListener
 * @see Collection#event:add
 * @see Collection#add
 */
/**
 * Callback signature for the {@link Collection#event:add} event.
 *
 * @example
 * function onAdd (recordOrRecords) {
 *   // do something
 * }
 * collection.on('add', onAdd);
 *
 * @callback Collection~addListener
 * @param {Record|Record[]} The Record or Records that were added.
 * @see Collection#event:add
 * @see Collection#add
 * @since 3.0.0
 */
/**
 * Fired when one or more records are removed from the Collection. See
 * {@link Collection~removeListener} for how to listen for this event.
 *
 * @event Collection#remove
 * @see Collection~removeListener
 * @see Collection#event:remove
 * @see Collection#remove
 * @see Collection#removeAll
 */
/**
 * Callback signature for the {@link Collection#event:remove} event.
 *
 * @example
 * function onRemove (recordsOrRecords) {
 *   // do something
 * }
 * collection.on('remove', onRemove);
 *
 * @callback Collection~removeListener
 * @param {Record|Record[]} Record or Records that were removed.
 * @see Collection#event:remove
 * @see Collection#remove
 * @see Collection#removeAll
 * @since 3.0.0
 */
/**
 * Create a subclass of this Collection:
 * @example <caption>Collection.extend</caption>
 * const JSData = require('js-data');
 * const { Collection } = JSData;
 * console.log('Using JSData v' + JSData.version.full);
 *
 * // Extend the class using ES2015 class syntax.
 * class CustomCollectionClass extends Collection {
 *   foo () { return 'bar'; }
 *   static beep () { return 'boop'; }
 * }
 * const customCollection = new CustomCollectionClass();
 * console.log(customCollection.foo());
 * console.log(CustomCollectionClass.beep());
 *
 * // Extend the class using alternate method.
 * const OtherCollectionClass = Collection.extend({
 *   foo () { return 'bar'; }
 * }, {
 *   beep () { return 'boop'; }
 * });
 * const otherCollection = new OtherCollectionClass();
 * console.log(otherCollection.foo());
 * console.log(OtherCollectionClass.beep());
 *
 * // Extend the class, providing a custom constructor.
 * function AnotherCollectionClass () {
 *   Collection.call(this);
 *   this.created_at = new Date().getTime();
 * }
 * Collection.extend({
 *   constructor: AnotherCollectionClass,
 *   foo () { return 'bar'; }
 * }, {
 *   beep () { return 'boop'; }
 * });
 * const anotherCollection = new AnotherCollectionClass();
 * console.log(anotherCollection.created_at);
 * console.log(anotherCollection.foo());
 * console.log(AnotherCollectionClass.beep());
 *
 * @method Collection.extend
 * @param {object} [props={}] Properties to add to the prototype of the
 * subclass.
 * @param {object} [props.constructor] Provide a custom constructor function
 * to be used as the subclass itself.
 * @param {object} [classProps={}] Static properties to add to the subclass.
 * @returns {Constructor} Subclass of this Collection class.
 * @since 3.0.0
 */
